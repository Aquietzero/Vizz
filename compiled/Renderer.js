// Generated by CoffeeScript 1.3.3
(function() {
  var INTERSECTED, Renderer, SELECTED, mouse, offset, plane, projector,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  mouse = new THREE.Vector2();

  offset = new THREE.Vector3();

  SELECTED = null;

  INTERSECTED = null;

  projector = new THREE.Projector();

  plane = new THREE.Mesh(new THREE.PlaneGeometry(2000, 2000, 8, 8), new THREE.MeshBasicMaterial({
    color: 0x000000
  }));

  plane.geometry.applyMatrix(new THREE.Matrix4().makeRotationX(Math.PI / 2));

  plane.visible = false;

  Renderer = (function() {

    function Renderer(container) {
      this.container = container;
      this.onMouseUp = __bind(this.onMouseUp, this);

      this.onMouseDown = __bind(this.onMouseDown, this);

      this.onMouseMove = __bind(this.onMouseMove, this);

      this.width = window.innerWidth;
      this.height = window.innerHeight;
      this.initThree();
      this.initScene();
      this.initCamera();
      this.initLight();
      this.initControls();
      this.initMouseEvents();
      this.objects = [];
    }

    Renderer.prototype.initThree = function() {
      this.renderer = new THREE.WebGLRenderer({
        antialias: true
      });
      this.renderer.setSize(this.width, this.height);
      document.getElementById(this.container).appendChild(this.renderer.domElement);
      this.renderer.setClearColorHex(0x000000, 1.0);
      this.renderer.shadowMapEnabled = true;
      return this.renderer.shadowMapSoft = true;
    };

    Renderer.prototype.initScene = function() {
      return this.scene = new THREE.Scene();
    };

    Renderer.prototype.initCamera = function() {
      this.camera = new THREE.PerspectiveCamera(45, this.width / this.height, 0.01, 1e10);
      this.camera.position.set(500, 800, 500);
      this.camera.up.set(0, 1, 0);
      this.camera.lookAt({
        x: 0,
        y: 150,
        z: 0
      });
      return this.scene.add(this.camera);
    };

    Renderer.prototype.initLight = function() {
      var ambientLight, directionalLight;
      directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
      directionalLight.position.set(50, 100, 200);
      directionalLight.castShadow = true;
      directionalLight.shadowBias = -0.00022;
      directionalLight.shadowDarkness = 0.5;
      directionalLight.shadowMapWidth = 1024;
      directionalLight.shadowMapHeight = 1024;
      ambientLight = new THREE.AmbientLight(0x111111, 0.1);
      this.scene.add(directionalLight);
      return this.scene.add(ambientLight);
    };

    Renderer.prototype.initControls = function() {
      this.controls = new THREE.TrackballControls(this.camera);
      this.controls.rotateSpeed = 1.0;
      this.controls.zoomSpeed = 1.3;
      this.controls.panSpeed = 0.8;
      return this.controls.keys = [65, 83, 68];
    };

    Renderer.prototype.add = function(obj) {
      this.objects.push(obj);
      return this.scene.add(obj.getGeometry());
    };

    Renderer.prototype.render = function() {
      this.controls.update();
      this.renderer.clear();
      return this.renderer.render(this.scene, this.camera);
    };

    Renderer.prototype.initMouseEvents = function() {
      this.scene.add(this.plane);
      this.renderer.domElement.addEventListener('mousemove', this.onMouseMove, false);
      this.renderer.domElement.addEventListener('mousedown', this.onMouseDown, false);
      return this.renderer.domElement.addEventListener('mouseup', this.onMouseUp, false);
    };

    Renderer.prototype.onMouseMove = function(event) {
      var intersects, obj, objects, ray, vector;
      event.preventDefault();
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
      vector = new THREE.Vector3(mouse.x, mouse.y, 0.5);
      projector.unprojectVector(vector, this.camera);
      ray = new THREE.Ray(this.camera.position, vector.subSelf(this.camera.position).normalize());
      if (SELECTED) {
        intersects = ray.intersectObject(plane);
        SELECTED.position.copy(intersects[0].point.subSelf(offset));
        return;
      }
      objects = (function() {
        var _i, _len, _ref, _results;
        _ref = this.objects;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          obj = _ref[_i];
          _results.push(obj.getGeometry());
        }
        return _results;
      }).call(this);
      intersects = ray.intersectObjects(objects);
      if (intersects.length > 0) {
        if (INTERSECTED !== intersects[0].object) {
          INTERSECTED = intersects[0].object;
          plane.position.copy(INTERSECTED.position);
          plane.lookAt(this.camera.position);
        }
        return this.renderer.domElement.style.cursor = 'pointer';
      } else {
        if (INTERSECTED) {
          INTERSECTED = null;
          return this.renderer.domElement.style.cursor = 'auto';
        }
      }
    };

    Renderer.prototype.onMouseDown = function(event) {
      var intersects, obj, objects, ray, vector;
      event.preventDefault();
      vector = new THREE.Vector3(mouse.x, mouse.y, 0.5);
      projector.unprojectVector(vector, this.camera);
      ray = new THREE.Ray(this.camera.position, vector.subSelf(this.camera.position).normalize());
      objects = (function() {
        var _i, _len, _ref, _results;
        _ref = this.objects;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          obj = _ref[_i];
          _results.push(obj.getGeometry());
        }
        return _results;
      }).call(this);
      intersects = ray.intersectObjects(objects);
      if (intersects.length > 0) {
        this.controls.enabled = false;
        SELECTED = intersects[0].object;
        intersects = ray.intersectObject(plane);
        offset.copy(intersects[0].point).subSelf(plane.position);
        return this.renderer.domElement.style.cursor = 'move';
      }
    };

    Renderer.prototype.onMouseUp = function(event) {
      event.preventDefault();
      this.controls.enabled = true;
      if (INTERSECTED) {
        plane.position.copy(INTERSECTED.position);
        SELECTED = null;
      }
      return this.renderer.domElement.style.cursor = 'auto';
    };

    return Renderer;

  })();

  this.Vizz.Renderer = Renderer;

}).call(this);
